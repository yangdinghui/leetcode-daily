package cn.leetcode.剑指Offer.数组中数字出现的次数2;

/**
 * @author yangdh
 * @desc 数组中数字出现的次数2: 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
 * 位运算 数组
 * @date 2023/3/24 17:43
 */
public class Solution23032502 {
    /**
     * 如果一个数字出现3次，它的二进制每一位也出现的3次。如果把所有的出现三次的数字的二进制表示的每一位都分别加起来，那么每一位都能被3整除。
     * 我们把数组中所有的数字的二进制表示的每一位都加起来。如果某一位能被3整除，那么这一位对只出现一次的那个数的这一肯定为0。
     * 如果某一位不能被3整除，那么只出现一次的那个数字的该位置一定为1.
     *
     * @param nums
     * @return
     */
    public int singleNumber(int[] nums) {
        int[] k = new int[32];
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < 32; j++) {
                k[j] += (nums[i] >> j & 1) == 1 ? 1 : 0;
            }
        }
        int res = 0;
        for (int i = 31; i >= 0; i--) {
            res = res << 1;
            if (k[i] % 3 == 1) {
                res = (res | 1);
            }
        }
        return res;
    }

    public int singleNumber2(int[] nums) {
        // 可以设计一种逻辑，使数字出现 3 次时，该逻辑的结果为 0（即只有 0，1，2 三种状态）
        // 其实就是一个 三进制
        // 一位二进制数只能存储 0 和 1 两种状态，所以我们需要用到两位二进制
        // 设两位二进制数的高位为 A，低位为 B。C 是输入变量
        // 表示的三种情况为 ： 0次：00(A=0,B=0), 1次：01(A=0,B=1), 2次：10(A=1,B=0)
        // 注：11(A=1,B=1) 为无效输入

        // 画出关于 A 的卡诺图（AB为11的结果是不重要的，用 x 表示）：
        //  AB\C |  0  |  1
        //  =================
        //    00 |  0  |  0
        //    01 |  0  |  1        ====> 得到 A = BC + AC'
        //    11 |  x  |  x
        //    10 |  1  |  0

        //  画出关于 B 的卡诺图
        //  AB\C |  0  |  1
        //  =================
        //    00 |  0  |  1
        //    01 |  1  |  0        ====> 得到 B = BC' + A'B'C
        //    11 |  x  |  x
        //    10 |  0  |  0

        // 很明显啊，我们需要的就是只出现一次的情况 01（A=0，B=1），即 B 的结果
        int A = 0, B = 0;
        for (int C : nums) {
            int tmp = A;
            A = (B & C) | (A & ~C);
            B = (B & ~C) | (~tmp & ~B & C);
        }
        return B;
    }
}
